import { IMapWillChange, IMapDidChange, IKeyValueMap, Lambda, IInterceptor } from "mobx";
import { IJsonPatch, INode, IType, IComplexType, ComplexType, TypeFlags, IContext, IValidationResult, ObjectNode, IChildNodesMap, IAnyType } from "../../internal";
export interface IMSTMap<C, S, T> {
    clear(): void;
    delete(key: string): boolean;
    forEach(callbackfn: (value: T, key: string, map: IMSTMap<C, S, T>) => void, thisArg?: any): void;
    get(key: string): T | undefined;
    has(key: string): boolean;
    set(key: string, value: C | S | T): this;
    readonly size: number;
    put(value: C | S | T): T;
    keys(): IterableIterator<string>;
    values(): IterableIterator<T>;
    entries(): IterableIterator<[string, T]>;
    [Symbol.iterator](): IterableIterator<[string, T]>;
    /** Merge another object into this map, returns self. */
    merge(other: IMSTMap<any, any, T> | IKeyValueMap<C | S | T> | any): this;
    clear(): void;
    replace(values: IMSTMap<any, any, T> | IKeyValueMap<T>): this;
    /**
     * Returns a plain object that represents this map.
     * Note that all the keys being stringified.
     * If there are duplicating keys after converting them to strings, behaviour is undetermined.
     */
    toPOJO(): IKeyValueMap<T>;
    /**
     * Returns a shallow non observable object clone of this map.
     * Note that the values migth still be observable. For a deep clone use mobx.toJS.
     */
    toJS(): Map<string, T>;
    toJSON(): IKeyValueMap<T>;
    toString(): string;
    [Symbol.toStringTag]: "Map";
    /**
     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
     * for callback details
     */
    observe(listener: (changes: IMapDidChange<string, T>) => void, fireImmediately?: boolean): Lambda;
    intercept(handler: IInterceptor<IMapWillChange<string, T>>): Lambda;
}
export declare enum MapIdentifierMode {
    UNKNOWN = 0,
    YES = 1,
    NO = 2,
}
export declare class MapType<C, S, T> extends ComplexType<IKeyValueMap<C>, IKeyValueMap<S>, IMSTMap<C, S, T>> {
    shouldAttachNode: boolean;
    subType: IAnyType;
    identifierMode: MapIdentifierMode;
    identifierAttribute: string | undefined;
    readonly flags: TypeFlags;
    constructor(name: string, subType: IAnyType);
    instantiate(parent: ObjectNode | null, subpath: string, environment: any, snapshot: S): INode;
    private _determineIdentifierMode();
    initializeChildNodes(objNode: ObjectNode, initialSnapshot?: any): IChildNodesMap;
    describe(): string;
    createNewInstance(childNodes: IChildNodesMap): IMSTMap<any, any, any>;
    finalizeNewInstance(node: INode): void;
    getChildren(node: ObjectNode): ReadonlyArray<INode>;
    getChildNode(node: ObjectNode, key: string): INode;
    willChange(change: IMapWillChange<any, any>): IMapWillChange<any, any> | null;
    private processIdentifier(expected, node);
    getValue(node: ObjectNode): any;
    getSnapshot(node: ObjectNode): IKeyValueMap<S>;
    didChange(change: IMapDidChange<any, any>): void;
    applyPatchLocally(node: ObjectNode, subpath: string, patch: IJsonPatch): void;
    applySnapshot(node: ObjectNode, snapshot: any): void;
    getChildType(key: string): IAnyType;
    isValidSnapshot(value: any, context: IContext): IValidationResult;
    getDefaultSnapshot(): {};
    removeChild(node: ObjectNode, subpath: string): void;
}
export declare function map<C, S, T>(subtype: IType<C, S, T>): IComplexType<IKeyValueMap<C>, IKeyValueMap<S>, IMSTMap<C, S, T>>;
export declare function isMapType<C, S, T>(type: any): type is IComplexType<IKeyValueMap<C>, IKeyValueMap<S>, IMSTMap<C, S, T>>;

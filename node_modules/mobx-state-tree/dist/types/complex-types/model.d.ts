import { IObjectWillChange, IObservableArray } from "mobx";
import { IStateTreeNode, IJsonPatch, INode, ComplexType, IComplexType, IType, TypeFlags, IContext, IValidationResult, ObjectNode, IChildNodesMap, IAnyType, IMSTMap } from "../../internal";
export declare enum HookNames {
    afterCreate = "afterCreate",
    afterAttach = "afterAttach",
    beforeDetach = "beforeDetach",
    beforeDestroy = "beforeDestroy",
}
export declare type ModelProperties = {
    [key: string]: IAnyType;
};
export declare type ModelPrimitive = string | number | boolean | Date;
export declare type ModelPropertiesDeclaration = {
    [key: string]: ModelPrimitive | IAnyType;
};
/**
 * Unmaps syntax property declarations to a map of { propName: IType }
 */
export declare type ModelPropertiesDeclarationToProperties<T extends ModelPropertiesDeclaration> = {
    [K in keyof T]: T[K] extends string ? IType<string | undefined, string, string> & {
        flags: TypeFlags.Optional;
    } : T[K] extends number ? IType<number | undefined, number, number> & {
        flags: TypeFlags.Optional;
    } : T[K] extends boolean ? IType<boolean | undefined, boolean, boolean> & {
        flags: TypeFlags.Optional;
    } : T[K] extends Date ? IType<number | undefined, number, Date> & {
        flags: TypeFlags.Optional;
    } : T[K] extends (IComplexType<infer C, infer S, IObservableArray<infer A>>) ? IComplexType<C, S, IObservableArray<A>> & {
        flags: TypeFlags.Optional;
    } : T[K] extends (IComplexType<infer C, infer S, IMSTMap<infer X, infer Y, infer Z>>) ? IComplexType<C, S, IMSTMap<X, Y, Z>> & {
        flags: TypeFlags.Optional;
    } : T[K] extends IType<infer C, infer S, infer A> & {
        flags: TypeFlags.Optional;
    } ? IType<C, S, A> & {
        flags: TypeFlags.Optional;
    } : T[K] extends IType<infer C, infer S, infer A> ? IType<C, S, A> : never;
};
export declare type OptionalPropertyTypes = ModelPrimitive | {
    flags: TypeFlags.Optional;
};
export declare type RequiredPropNames<T> = {
    [K in keyof T]: T[K] extends OptionalPropertyTypes ? never : undefined extends T[K] ? never : K;
}[keyof T];
export declare type RequiredProps<T> = Pick<T, RequiredPropNames<T>>;
export declare type OptionalPropNames<T> = {
    [K in keyof T]: T[K] extends OptionalPropertyTypes ? K : never;
}[keyof T];
export declare type OptionalProps<T> = Pick<T, OptionalPropNames<T>>;
/**
 * Maps property types to the snapshot, including omitted optional attributes
 */
export declare type ModelCreationType<T extends ModelProperties> = {
    readonly [K in keyof RequiredProps<T>]: T[K] extends IType<infer X, any, infer Y> ? X | Y : never;
} & {
    readonly [K in keyof OptionalProps<T>]?: T[K] extends IType<infer X, any, infer Y> ? X | Y : never;
};
export declare type ModelSnapshotType<T extends ModelProperties> = {
    readonly [K in keyof RequiredProps<T>]: T[K] extends IType<any, infer X, any> ? X : never;
} & {
    readonly [K in keyof OptionalProps<T>]: T[K] extends IType<any, infer X, any> ? X : never;
};
export declare type ModelInstanceType<T extends ModelProperties, O> = {
    [K in keyof T]: T[K] extends IType<any, any, infer X> ? X : never;
} & O & IStateTreeNode;
export declare type ModelActions = {
    [key: string]: Function;
};
export interface IModelType<PROPS extends ModelProperties, OTHERS, C = ModelCreationType<PROPS>, S = ModelSnapshotType<PROPS>, T = ModelInstanceType<PROPS, OTHERS>> extends IComplexType<C, S, T> {
    readonly properties: PROPS;
    named(newName: string): this;
    props<PROPS2 extends ModelPropertiesDeclaration>(props: PROPS2): IModelType<PROPS & ModelPropertiesDeclarationToProperties<PROPS2>, OTHERS>;
    views<V extends Object>(fn: (self: ModelInstanceType<PROPS, OTHERS>) => V): IModelType<PROPS, OTHERS & V>;
    actions<A extends ModelActions>(fn: (self: ModelInstanceType<PROPS, OTHERS>) => A): IModelType<PROPS, OTHERS & A>;
    volatile<TP extends object>(fn: (self: ModelInstanceType<PROPS, OTHERS>) => TP): IModelType<PROPS, OTHERS & TP>;
    extend<A extends ModelActions = {}, V extends Object = {}, VS extends Object = {}>(fn: (self: ModelInstanceType<PROPS, OTHERS>) => {
        actions?: A;
        views?: V;
        state?: VS;
    }): IModelType<PROPS, OTHERS & A & V & VS>;
    preProcessSnapshot<S0 = ModelCreationType<PROPS>>(fn: (snapshot: S0) => ModelCreationType<PROPS>): IModelType<PROPS, OTHERS, S0>;
    postProcessSnapshot<S1 = ModelCreationType<PROPS>>(fn: (snapshot: ModelSnapshotType<PROPS>) => S1): IModelType<PROPS, OTHERS, S1>;
}
export declare type ModelTypeConfig = {
    name?: string;
    properties?: ModelProperties;
    initializers?: ReadonlyArray<((instance: any) => any)>;
    preProcessor?: (snapshot: any) => any;
    postProcessor?: (snapshot: any) => any;
};
export declare class ModelType<S extends ModelProperties, T> extends ComplexType<any, any, any> implements IModelType<S, T> {
    readonly flags: TypeFlags;
    shouldAttachNode: boolean;
    readonly identifierAttribute: string | undefined;
    readonly initializers: ((instance: any) => any)[];
    readonly properties: any;
    private preProcessor;
    private postProcessor;
    private readonly propertyNames;
    constructor(opts: ModelTypeConfig);
    private _getIdentifierAttribute();
    cloneAndEnhance(opts: ModelTypeConfig): ModelType<any, any>;
    actions(fn: (self: any) => any): any;
    instantiateActions(self: T, actions: any): void;
    named(name: string): this;
    props(properties: ModelPropertiesDeclaration): any;
    volatile(fn: (self: any) => any): any;
    instantiateVolatileState(self: T, state: Object): void;
    extend(fn: (self: any) => any): any;
    views(fn: (self: any) => any): any;
    instantiateViews(self: T, views: Object): void;
    preProcessSnapshot(preProcessor: (snapshot: any) => any): any;
    postProcessSnapshot(postProcessor: (snapshot: any) => any): any;
    instantiate(parent: ObjectNode | null, subpath: string, environment: any, snapshot: any): INode;
    initializeChildNodes(objNode: ObjectNode, initialSnapshot?: any): IChildNodesMap;
    createNewInstance(): Object;
    finalizeNewInstance(node: INode, childNodes: IChildNodesMap): void;
    willChange(change: any): IObjectWillChange | null;
    didChange(change: any): void;
    getChildren(node: ObjectNode): INode[];
    getChildNode(node: ObjectNode, key: string): INode;
    getValue(node: ObjectNode): any;
    getSnapshot(node: ObjectNode, applyPostProcess?: boolean): any;
    applyPatchLocally(node: ObjectNode, subpath: string, patch: IJsonPatch): void;
    applySnapshot(node: ObjectNode, snapshot: any): void;
    applySnapshotPreProcessor(snapshot: any): any;
    applySnapshotPostProcessor(snapshot: any): any;
    getChildType(key: string): IAnyType;
    isValidSnapshot(value: any, context: IContext): IValidationResult;
    private forAllProps(fn);
    describe(): string;
    getDefaultSnapshot(): any;
    removeChild(node: ObjectNode, subpath: string): void;
}
export declare function model<T extends ModelPropertiesDeclaration = {}>(name: string, properties?: T): IModelType<ModelPropertiesDeclarationToProperties<T>, {}>;
export declare function model<T extends ModelPropertiesDeclaration = {}>(properties?: T): IModelType<ModelPropertiesDeclarationToProperties<T>, {}>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>): IModelType<T1 & T2, S1 & S2>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>): IModelType<T1 & T2 & T3, S1 & S2 & S3>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>): IModelType<T1 & T2 & T3 & T4, S1 & S2 & S3 & S4>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>): IModelType<T1 & T2 & T3 & T4 & T5, S1 & S2 & S3 & S4 & S5>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5, T6 extends ModelProperties, S6>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>, t6: IModelType<T6, S6>): IModelType<T1 & T2 & T3 & T4 & T5 & T6, S1 & S2 & S3 & S4 & S5 & S6>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5, T6 extends ModelProperties, S6, T7 extends ModelProperties, S7>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>, t6: IModelType<T6, S6>, t7: IModelType<T7, S7>): IModelType<T1 & T2 & T3 & T4 & T5 & T6 & T7, S1 & S2 & S3 & S4 & S5 & S6 & S7>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5, T6 extends ModelProperties, S6, T7 extends ModelProperties, S7, T8 extends ModelProperties, S8>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>, t6: IModelType<T6, S6>, t7: IModelType<T7, S7>, t8: IModelType<T8, S8>): IModelType<T1 & T2 & T3 & T4 & T5 & T6 & T7 & T8, S1 & S2 & S3 & S4 & S5 & S6 & S7 & S8>;
export declare function compose<T1 extends ModelProperties, S1, T2 extends ModelProperties, S2, T3 extends ModelProperties, S3, T4 extends ModelProperties, S4, T5 extends ModelProperties, S5, T6 extends ModelProperties, S6, T7 extends ModelProperties, S7, T8 extends ModelProperties, S8, T9 extends ModelProperties, S9>(t1: IModelType<T1, S1>, t2: IModelType<T2, S2>, t3: IModelType<T3, S3>, t4: IModelType<T4, S4>, t5: IModelType<T5, S5>, t6: IModelType<T6, S6>, t7: IModelType<T7, S7>, t8: IModelType<T8, S8>, t9: IModelType<T9, S9>): IModelType<T1 & T2 & T3 & T4 & T5 & T6 & T7 & T8 & T9, S1 & S2 & S3 & S4 & S5 & S6 & S7 & S8 & S9>;
export declare function isModelType(type: any): type is ModelType<any, any>;
